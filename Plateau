package Netwalk;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import Outils.Data;

public class Plateau {

    private Tuile[][] grille;
    private int nbLignes;
    private int nbColonnes;
    private int ligneServeur;
    private int colonneServeur;

    // Index pour les déplacement: 0=Nord; 1=Est; 2=Sud; 3=Ouest
    private final int[] deplacementLigne =   {-1, 0, 1,  0};
    private final int[] deplacementColonne = { 0, 1, 0, -1};

    public Plateau(String nomFichier) {
        chargerFichier(nomFichier);
    }

    public Plateau(int nbLignes, int nbColonnes) {
        this.nbLignes = nbLignes;
        this.nbColonnes = nbColonnes;
        initialiserPlateauVide();
        placerServeurAleatoirement();
        boolean[][] dejaVisite = new boolean[nbLignes][nbColonnes];
        genererParcoursProfondeur(ligneServeur, colonneServeur, dejaVisite);
        detecterFeuilles();
        melangerTuiles();
    }

    // Génération du Plateau (parcours en profondeur)

    private void genererParcoursProfondeur(int ligneActuelle, int colonneActuelle, boolean[][] dejaVisite) {
        dejaVisite[ligneActuelle][colonneActuelle] = true;

        ArrayList<Integer> ordreExploration = obtenirDirectionsAleatoires();

        for (int directionIndex : ordreExploration) {
            int ligneVoisin = ligneActuelle + deplacementLigne[directionIndex];
            int colonneVoisin = colonneActuelle + deplacementColonne[directionIndex];

            if (estDansPlateau(ligneVoisin, colonneVoisin) && !dejaVisite[ligneVoisin][colonneVoisin]) {
                // On ouvre le passage pour les 2 tuiles
                passageOuvert(ligneActuelle, colonneActuelle, Data.direction[directionIndex]);
                passageOuvert(ligneVoisin, colonneVoisin, Data.directionOpposee[directionIndex]);

                genererParcoursProfondeur(ligneVoisin, colonneVoisin, dejaVisite);
            }
        }
    }

    // Algorithme de vérification (Victoire ou non)
        
    // Vérifie si le joueur a gagné
    public boolean estGagne() {
        reinitialiseTuilesVisitees();
        parcoursVerification(ligneServeur, colonneServeur);
        return pilesTuilesVisitees();
    }

    private void parcoursVerification(int ligneActuelle, int colonneActuelle) {
        grille[ligneActuelle][colonneActuelle].setVisitee(true);
        Tuile tuileActuelle = grille[ligneActuelle][colonneActuelle];

        // On teste les 4 directions possibles (de 0 à 3)
        for (int i = 0; i < 4; i++) {
            int direction = Data.direction[i];

            // Est ce que la tuile actuelle a une sortie dans la direction
            if ((tuileActuelle.getCode() & direction) != 0) {
                int ligneVoisin = ligneActuelle + deplacementLigne[i];
                int colonneVoisin = colonneActuelle + deplacementColonne[i];

                if (estDansPlateau(ligneVoisin, colonneVoisin)) {
                    Tuile voisin = grille[ligneVoisin][colonneVoisin];
                    int directionOpposee = Data.dirOpp(direction);

                    // Est ce que voisin a une entrée dans la direction opposée et n'est pas visité
                    if ((voisin.getCode() & directionOpposee) != 0 && !voisin.isVisitee()) {
                        parcoursVerification(ligneVoisin, colonneVoisin);
                    }
                }
            }
        }
    }

    // Méthodes algorithme récursif

    private void passageOuvert(int l, int c, int direction) {
        grille[l][c].setCode(grille[l][c].getCode() | direction);
    }

    private boolean estDansPlateau(int l, int c) {
        return l >= 0 && l < nbLignes && c >= 0 && c < nbColonnes;
    }

    private void reinitialiseTuilesVisitees() {
        for (int i = 0; i < nbLignes; i++)
            for (int j = 0; j < nbColonnes; j++)
                grille[i][j].setVisitee(false);
    }

    private boolean pilesTuilesVisitees() {
        for (int i = 0; i < nbLignes; i++)
            for (int j = 0; j < nbColonnes; j++)
                if (!grille[i][j].isVisitee()) return false;
        return true;
    }

    private ArrayList<Integer> obtenirDirectionsAleatoires() {
        ArrayList<Integer> directions = new ArrayList<>();
        for (int i = 0; i < 4; i++) directions.add(i);
        Collections.shuffle(directions);
        return directions;
    }

    // Autres Méthodes

    private void chargerFichier(String nomFichier) {
        try (BufferedReader fichier = new BufferedReader(new FileReader(nomFichier))) {
            this.nbLignes = Integer.parseInt(fichier.readLine());
            this.nbColonnes = Integer.parseInt(fichier.readLine());
            this.grille = new Tuile[nbLignes][nbColonnes];
            
            String[] coordonéesTuiles = fichier.readLine().split(",");
            this.colonneServeur = Integer.parseInt(coordonéesTuiles[0]);
            this.ligneServeur = Integer.parseInt(coordonéesTuiles[1]);

            for (int i = 0; i < nbLignes; i++) {
                String[] valeurs = fichier.readLine().split(";");
                for (int j = 0; j < nbColonnes; j++) {
                    grille[i][j] = new Tuile(Integer.parseInt(valeurs[j]));
                }
            }
            if (estDansPlateau(ligneServeur, colonneServeur))
                grille[ligneServeur][colonneServeur].setServeur(true);
            detecterFeuilles();
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
    }

    private void initialiserPlateauVide() {
        this.grille = new Tuile[nbLignes][nbColonnes];
        for (int i = 0; i < nbLignes; i++)
            for (int j = 0; j < nbColonnes; j++)
                grille[i][j] = new Tuile(0);
    }

    private void placerServeurAleatoirement() {
        this.ligneServeur = (int) (Math.random() * nbLignes);
        this.colonneServeur = (int) (Math.random() * nbColonnes);
        this.grille[ligneServeur][colonneServeur].setServeur(true);
    }

    private void detecterFeuilles() {
        for (int i = 0; i < nbLignes; i++) {
            for (int j = 0; j < nbColonnes; j++) {
                int code = grille[i][j].getCode();
                boolean estExtremite = (code == 1 || code == 2 || code == 4 || code == 8);
                grille[i][j].setFeuille(estExtremite && !grille[i][j].isServeur());
            }
        }
    }

    private void melangerTuiles() {
        for (int i = 0; i < nbLignes; i++)
            for (int j = 0; j < nbColonnes; j++) {
                int nonbreDeRotation = (int) (Math.random() * 4);
                for (int k = 0; k < nonbreDeRotation; k++)
                    grille[i][j].rotationDroite();
            }
    }

    public void tournerTuile(int ligne, int colonne) {
        if (estDansPlateau(ligne, colonne))
            grille[ligne][colonne].rotationDroite();
    }

    @Override
    public String toString() {
        return afficherNumeroColonne() + afficherBordureSuperieure() + afficherContenuPlateau() + afficherBordureInferieure();
    }

    private String afficherNumeroColonne() {
        String numeroColonne = "    ";
        for (int colonne = 0; colonne < nbColonnes; colonne++)
            numeroColonne += "  " + colonne;
        return numeroColonne + "\n";
    }

    private String afficherBordureSuperieure() {
        String BordureSuperieure = "  " + Data.asciiGraphic[6];
        for (int i = 0; i < nbColonnes; i++)
            BordureSuperieure += Data.asciiGraphic[10];
        return BordureSuperieure + Data.asciiGraphic[12] + "\n";
    }

    
    private String afficherContenuPlateau() {
        String contenuPlateau = "";
        for (int i = 0; i < nbLignes; i++) {
            contenuPlateau += i + " " + Data.asciiGraphic[5];
            for (int j = 0; j < nbColonnes; j++) {
                contenuPlateau += grille[i][j].toString();
                }
            contenuPlateau += Data.asciiGraphic[5] + "\n"; 
        }
        return contenuPlateau;
    }   


    private String afficherBordureInferieure() {
        String bordureInferieure = "  " + Data.asciiGraphic[3];
        for (int i = 0; i < nbColonnes; i++)
            bordureInferieure += Data.asciiGraphic[10];
        return bordureInferieure + Data.asciiGraphic[9] + "\n";
    }
}
